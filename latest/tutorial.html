<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction to Knet · Knet.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Knet.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="install.html">Setting up Knet</a></li><li class="current"><a class="toctext" href="tutorial.html">Introduction to Knet</a><ul class="internal"><li><a class="toctext" href="#Philosophy-1">Philosophy</a></li><li><a class="toctext" href="#Tutorial-1">Tutorial</a></li><li><a class="toctext" href="#Benchmarks-1">Benchmarks</a></li><li><a class="toctext" href="#Under-the-hood-1">Under the hood</a></li><li><a class="toctext" href="#Contributing-1">Contributing</a></li></ul></li><li><a class="toctext" href="examples.html">Examples</a></li><li><a class="toctext" href="reference.html">Reference</a></li></ul></li><li><span class="toctext">Textbook</span><ul><li><a class="toctext" href="backprop.html">Backpropagation</a></li><li><a class="toctext" href="softmax.html">Softmax Classification</a></li><li><a class="toctext" href="mlp.html">Multilayer Perceptrons</a></li><li><a class="toctext" href="cnn.html">Convolutional Neural Networks</a></li><li><a class="toctext" href="rnn.html">Recurrent Neural Networks</a></li><li><a class="toctext" href="rl.html">Reinforcement Learning</a></li><li><a class="toctext" href="opt.html">Optimization</a></li><li><a class="toctext" href="gen.html">Generalization</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="tutorial.html">Introduction to Knet</a></li></ul><a class="edit-page" href="https://github.com/denizyuret/Knet.jl/tree/e24ab3bd4c316e65ec77396cddd72ed191ef6755/docs/src/tutorial.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Introduction to Knet</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Introduction-to-Knet-1" href="#Introduction-to-Knet-1">Introduction to Knet</a></h1><p><a href="https://denizyuret.github.io/Knet.jl/latest"><img src="https://img.shields.io/badge/docs-latest-blue.svg" alt/></a> <a href="http://pkg.julialang.org/?pkg=Knet"><img src="http://pkg.julialang.org/badges/Knet_0.4.svg" alt/></a> <a href="http://pkg.julialang.org/?pkg=Knet"><img src="http://pkg.julialang.org/badges/Knet_0.5.svg" alt/></a> <a href="https://travis-ci.org/denizyuret/Knet.jl"><img src="https://travis-ci.org/denizyuret/Knet.jl.svg?branch=master" alt/></a></p><p><a href="https://denizyuret.github.io/Knet.jl/latest">Knet</a> (pronounced &quot;kay-net&quot;) is the <a href="http://www.ku.edu.tr/en">Koç University</a> deep learning framework implemented in <a href="http://docs.julialang.org">Julia</a> by <a href="http://www.denizyuret.com">Deniz Yuret</a> and collaborators.  It supports GPU operation and automatic differentiation using dynamic computational graphs for models defined in plain Julia.  This document is a tutorial introduction to Knet.  Check out the <a href="https://denizyuret.github.io/Knet.jl/latest">full documentation</a> and <a href="examples.html#Examples-1">Examples</a> for more information. If you need help or would like to request a feature, please consider joining the <a href="https://groups.google.com/forum/#!forum/knet-users">knet-users</a> mailing list. If you find a bug, please open a <a href="https://github.com/denizyuret/Knet.jl/issues">GitHub issue</a>. If you would like to contribute to Knet development, check out the <a href="https://groups.google.com/forum/#!forum/knet-dev">knet-dev</a> mailing list and <a href="install.html#Tips-for-developers-1">Tips for developers</a>. If you use Knet in academic work, <a href="https://goo.gl/zeUBFr">here is a paper</a> that can be cited:</p><pre><code class="language-none">@inproceedings{knet2016mlsys,
  author={Yuret, Deniz},
  title={Knet: beginning deep learning with 100 lines of Julia},
  year={2016},
  booktitle={Machine Learning Systems Workshop at NIPS 2016}
}</code></pre><p><strong>Contents</strong></p><ul><li><a href="tutorial.html#Introduction-to-Knet-1">Introduction to Knet</a></li><ul><li><a href="tutorial.html#Philosophy-1">Philosophy</a></li><li><a href="tutorial.html#Tutorial-1">Tutorial</a></li><ul><li><a href="tutorial.html#Linear-regression-1">Linear regression</a></li><li><a href="tutorial.html#Softmax-classification-1">Softmax classification</a></li><li><a href="tutorial.html#Multi-layer-perceptron-1">Multi-layer perceptron</a></li><li><a href="tutorial.html#Convolutional-neural-network-1">Convolutional neural network</a></li><li><a href="tutorial.html#Recurrent-neural-network-1">Recurrent neural network</a></li></ul><li><a href="tutorial.html#Benchmarks-1">Benchmarks</a></li><li><a href="tutorial.html#Under-the-hood-1">Under the hood</a></li><ul><li><a href="tutorial.html#KnetArrays-1">KnetArrays</a></li><li><a href="tutorial.html#AutoGrad-1">AutoGrad</a></li></ul><li><a href="tutorial.html#Contributing-1">Contributing</a></li></ul></ul><h2><a class="nav-anchor" id="Philosophy-1" href="#Philosophy-1">Philosophy</a></h2><p>Knet uses dynamic computational graphs generated at runtime for automatic differentiation of (almost) any Julia code.  This allows machine learning models to be implemented by defining just the forward calculation (i.e. the computation from parameters and data to loss) using the full power and expressivity of Julia. The implementation can use helper functions, loops, conditionals, recursion, closures, tuples and dictionaries, array indexing, concatenation and other high level language features, some of which are often missing in the restricted modeling languages of static computational graph systems like Theano, Torch, Caffe and Tensorflow.  GPU operation is supported by simply using the KnetArray type instead of regular Array for parameters and data.</p><p>Knet builds a dynamic computational graph by recording primitive operations during forward calculation.  Only pointers to inputs and outputs are recorded for efficiency.  Therefore array overwriting is not supported during forward and backward passes.  This encourages a clean functional programming style.  High performance is achieved using custom memory management and efficient GPU kernels.  See <a href="tutorial.html#Under-the-hood-1">Under the hood</a> for more details.</p><h2><a class="nav-anchor" id="Tutorial-1" href="#Tutorial-1">Tutorial</a></h2><p>In Knet, a machine learning model is defined using plain Julia code. A typical model consists of a <strong>prediction</strong> and a <strong>loss</strong> function. The prediction function takes model parameters and some input, returns the prediction of the model for that input. The loss function measures how bad the prediction is with respect to some desired output. We train a model by adjusting its parameters to reduce the loss. In this section we will see the prediction, loss, and training functions for five models: linear regression, softmax classification, fully-connected, convolutional and recurrent neural networks.  It would be best to copy paste and modify these examples on your own computer.  You can install Knet using <code>Pkg.add(&quot;Knet&quot;)</code> in Julia.</p><h3><a class="nav-anchor" id="Linear-regression-1" href="#Linear-regression-1">Linear regression</a></h3><p>Here is the prediction function and the corresponding quadratic loss function for a simple linear regression model:</p><pre><code class="language-julia">predict(w,x) = w[1]*x .+ w[2]

loss(w,x,y) = sumabs2(y - predict(w,x)) / size(y,2)</code></pre><p>The variable <code>w</code> is a list of parameters (it could be a Tuple, Array, or Dict), <code>x</code> is the input and <code>y</code> is the desired output. To train this model, we want to adjust its parameters to reduce the loss on given training examples. The direction in the parameter space in which the loss reduction is maximum is given by the negative gradient of the loss. Knet uses the higher-order function <a href="reference.html#AutoGrad.grad"><code>grad</code></a> from <a href="https://github.com/denizyuret/AutoGrad.jl">AutoGrad.jl</a> to compute the gradient direction:</p><pre><code class="language-julia">using Knet

lossgradient = grad(loss)</code></pre><p>Note that <code>grad</code> is a higher-order function that takes and returns other functions. The <code>lossgradient</code> function takes the same arguments as <code>loss</code>, e.g. <code>dw = lossgradient(w,x,y)</code>. Instead of returning a loss value, <code>lossgradient</code> returns <code>dw</code>, the gradient of the loss with respect to its first argument <code>w</code>. The type and size of <code>dw</code> is identical to <code>w</code>, each entry in <code>dw</code> gives the derivative of the loss with respect to the corresponding entry in <code>w</code>. </p><p>Given some training <code>data = [(x1,y1),(x2,y2),...]</code>, here is how we can train this model:</p><pre><code class="language-julia">function train(w, data; lr=.1)
    for (x,y) in data
        dw = lossgradient(w, x, y)
        for i in 1:length(w)
            w[i] -= lr * dw[i]
        end
    end
    return w
end</code></pre><p>We simply iterate over the input-output pairs in data, calculate the lossgradient for each example, and move the parameters in the negative gradient direction with a step size determined by the learning rate <code>lr</code>.  See <a href="reference.html#Optimization-methods-1">Optimization methods</a> for more advanced algorithms.</p><blockquote><p><a href="https://archive.ics.uci.edu/ml/datasets/Housing"><img src="https://github.com/denizyuret/Knet.jl/blob/master/docs/src/images/housing.jpeg?raw=true" alt="image"/></a></p></blockquote><p>Let&#39;s train this model on the <a href="https://archive.ics.uci.edu/ml/datasets/Housing">Housing</a> dataset from the UCI Machine Learning Repository.</p><pre><code class="language-julia">julia&gt; url = &quot;https://archive.ics.uci.edu/ml/machine-learning-databases/housing/housing.data&quot;
julia&gt; rawdata = readdlm(download(url))
julia&gt; x = rawdata[:,1:13]&#39;
julia&gt; x = (x .- mean(x,2)) ./ std(x,2)
julia&gt; y = rawdata[:,14:14]&#39;
julia&gt; w = Any[ 0.1*randn(1,13), 0 ]
julia&gt; for i=1:10; train(w, [(x,y)]); println(loss(w,x,y)); end
366.0463078055053
...
29.63709385230451</code></pre><p>The dataset has housing related information for 506 neighborhoods in Boston from 1978. Each neighborhood is represented using 13 attributes such as crime rate or distance to employment centers. The goal is to predict the median value of the houses given in $1000&#39;s. After downloading, splitting and normalizing the data, we initialize the parameters randomly and take 10 steps in the negative gradient direction. We can see the loss dropping from 366.0 to 29.6. See <a href="https://github.com/denizyuret/Knet.jl/blob/master/examples/housing.jl">housing.jl</a> for more information on this example.</p><p>Note that <code>grad</code> was the only function used that is not in the Julia standard library. This is typical of models defined in Knet.</p><h3><a class="nav-anchor" id="Softmax-classification-1" href="#Softmax-classification-1">Softmax classification</a></h3><p>In this example we build a simple classification model for the <a href="http://yann.lecun.com/exdb/mnist">MNIST</a> handwritten digit recognition dataset. MNIST has 60000 training and 10000 test examples. Each input x consists of 784 pixels representing a 28x28 image. The corresponding output indicates the identity of the digit 0..9.</p><blockquote><p><a href="https://jamesmccaffrey.wordpress.com/2014/06/10/working-with-the-mnist-image-recognition-data-set"><img src="https://github.com/denizyuret/Knet.jl/blob/master/docs/src/images/firsteightimages.jpg?raw=true" alt="image"/></a></p></blockquote><p>(<a href="https://jamesmccaffrey.wordpress.com/2014/06/10/working-with-the-mnist-image-recognition-data-set">image source</a>)</p><p>Classification models handle discrete outputs, as opposed to regression models which handle numeric outputs. We typically use the cross entropy loss function in classification models:</p><pre><code class="language-julia">function loss(w,x,ygold)
    ypred = predict(w,x)
    ynorm = ypred .- log(sum(exp(ypred),1))
    -sum(ygold .* ynorm) / size(ygold,2)
end</code></pre><p>Other than the change of loss function, the softmax model is identical to the linear regression model. We use the same <code>predict</code>, same <code>train</code> and set <code>lossgradient=grad(loss)</code> as before. To see how well our model classifies let&#39;s define an <code>accuracy</code> function which returns the percentage of instances classified correctly:</p><pre><code class="language-julia">function accuracy(w, data)
    ncorrect = ninstance = 0
    for (x, ygold) in data
        ypred = predict(w,x)
        ncorrect += sum(ygold .* (ypred .== maximum(ypred,1)))
        ninstance += size(ygold,2)
    end
    return ncorrect/ninstance
end</code></pre><p>Now let&#39;s train a model on the MNIST data:</p><pre><code class="language-julia">julia&gt; include(Knet.dir(&quot;examples&quot;,&quot;mnist.jl&quot;))
julia&gt; using MNIST: xtrn, ytrn, xtst, ytst, minibatch
julia&gt; dtrn = minibatch(xtrn, ytrn, 100)
julia&gt; dtst = minibatch(xtst, ytst, 100)
julia&gt; w = Any[ -0.1+0.2*rand(Float32,10,784), zeros(Float32,10,1) ]
julia&gt; println((:epoch, 0, :trn, accuracy(w,dtrn), :tst, accuracy(w,dtst)))
julia&gt; for epoch=1:10
           train(w, dtrn; lr=0.5)
           println((:epoch, epoch, :trn, accuracy(w,dtrn), :tst, accuracy(w,dtst)))
       end

(:epoch,0,:trn,0.11761667f0,:tst,0.121f0)
(:epoch,1,:trn,0.9005f0,:tst,0.9048f0)
...
(:epoch,10,:trn,0.9196f0,:tst,0.9153f0)</code></pre><p>Including <code>mnist.jl</code> loads the MNIST data, downloading it from the internet if necessary, and provides a training set (xtrn,ytrn), test set (xtst,ytst) and a <code>minibatch</code> utility which we use to rearrange the data into chunks of 100 instances. After randomly initializing the parameters we train for 10 epochs, printing out training and test set accuracy at every epoch. The final accuracy of about 92% is close to the limit of what we can achieve with this type of model. To improve further we must look beyond linear models.</p><h3><a class="nav-anchor" id="Multi-layer-perceptron-1" href="#Multi-layer-perceptron-1">Multi-layer perceptron</a></h3><p>A multi-layer perceptron, i.e. a fully connected feed-forward neural network, is basically a bunch of linear regression models stuck together with non-linearities in between.</p><blockquote><p><a href="http://cs231n.github.io/neural-networks-1"><img src="https://github.com/denizyuret/Knet.jl/blob/master/docs/src/images/neural_net2.jpeg?raw=true" alt="image"/></a></p></blockquote><p>(<a href="http://cs231n.github.io/neural-networks-1">image source</a>)</p><p>We can define a MLP by slightly modifying the predict function:</p><pre><code class="language-julia">function predict(w,x)
    for i=1:2:length(w)-2
        x = max(0, w[i]*x .+ w[i+1])
    end
    return w[end-1]*x .+ w[end]
end</code></pre><p>Here <code>w[2k-1]</code> is the weight matrix and <code>w[2k]</code> is the bias vector for the k&#39;th layer. max(0,a) implements the popular rectifier non-linearity. Note that if w only has two entries, this is equivalent to the linear and softmax models. By adding more entries to w, we can define multi-layer perceptrons of arbitrary depth. Let&#39;s define one with a single hidden layer of 64 units:</p><pre><code class="language-julia">w = Any[ -0.1+0.2*rand(Float32,64,784), zeros(Float32,64,1),
         -0.1+0.2*rand(Float32,10,64),  zeros(Float32,10,1) ]</code></pre><p>The rest of the code is the same as the softmax model. We use the same cross-entropy loss function and the same training script. The code for this example is available in <a href="https://github.com/denizyuret/Knet.jl/blob/master/examples/mnist.jl">mnist.jl</a>. The multi-layer perceptron does significantly better than the softmax model:</p><pre><code class="language-julia">(:epoch,0,:trn,0.10166667f0,:tst,0.0977f0)
(:epoch,1,:trn,0.9389167f0,:tst,0.9407f0)
...
(:epoch,10,:trn,0.9866f0,:tst,0.9735f0)</code></pre><h3><a class="nav-anchor" id="Convolutional-neural-network-1" href="#Convolutional-neural-network-1">Convolutional neural network</a></h3><p>To improve the performance further, we can use a convolutional neural networks (CNN). See the <a href="http://cs231n.github.io/convolutional-networks/">course notes</a> by Andrej Karpathy for a good introduction to CNNs. We will implement the <a href="http://yann.lecun.com/exdb/lenet">LeNet</a> model which consists of two convolutional layers followed by two fully connected layers.</p><blockquote><p><a href="http://www.dataiku.com/blog/2015/08/18/Deep_Learning.html"><img src="https://github.com/denizyuret/Knet.jl/blob/master/docs/src/images/le_net.png?raw=true" alt="image"/></a></p></blockquote><p>(<a href="http://www.dataiku.com/blog/2015/08/18/Deep_Learning.html">image source</a>)</p><p>Knet provides the <a href="reference.html#Knet.conv4"><code>conv4</code></a> and <a href="reference.html#Knet.pool"><code>pool</code></a> functions for the implementation of convolutional nets:</p><pre><code class="language-julia">function predict(w,x0)
    x1 = pool(max(0, conv4(w[1],x0) .+ w[2]))
    x2 = pool(max(0, conv4(w[3],x1) .+ w[4]))
    x3 = max(0, w[5]*mat(x2) .+ w[6])
    return w[7]*x3 .+ w[8]
end</code></pre><p>The weights for the convolutional net can be initialized as follows:</p><pre><code class="language-julia">w = Any[ -0.1+0.2*rand(Float32,5,5,1,20),  zeros(Float32,1,1,20,1),
         -0.1+0.2*rand(Float32,5,5,20,50), zeros(Float32,1,1,50,1),
         -0.1+0.2*rand(Float32,500,800),   zeros(Float32,500,1),
         -0.1+0.2*rand(Float32,10,500),    zeros(Float32,10,1) ]</code></pre><p>Currently convolution and pooling are only supported on the GPU for 4-D and 5-D arrays. So we reshape our data and transfer it to the GPU along with the parameters by converting them into <a href="reference.html#Knet.KnetArray"><code>KnetArray</code></a>s:</p><pre><code class="language-julia">dtrn = map(d-&gt;(KnetArray(reshape(d[1],(28,28,1,100))), KnetArray(d[2])), dtrn)
dtst = map(d-&gt;(KnetArray(reshape(d[1],(28,28,1,100))), KnetArray(d[2])), dtst)
w = map(KnetArray, w)</code></pre><p>The training proceeds as before giving us even better results. The code for the LeNet example can be found in <a href="https://github.com/denizyuret/Knet.jl/blob/master/examples/lenet.jl">lenet.jl</a>.</p><pre><code class="language-julia">(:epoch,0,:trn,0.12215f0,:tst,0.1263f0)
(:epoch,1,:trn,0.96963334f0,:tst,0.971f0)
...
(:epoch,10,:trn,0.99553335f0,:tst,0.9879f0)</code></pre><h3><a class="nav-anchor" id="Recurrent-neural-network-1" href="#Recurrent-neural-network-1">Recurrent neural network</a></h3><p>In this section we will see how to implement a recurrent neural network (RNN) in Knet. An RNN is a class of neural network where connections between units form a directed cycle, which allows them to keep a persistent state over time. This gives them the ability to process sequences of arbitrary length one element at a time, while keeping track of what happened at previous elements.</p><blockquote><p><a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs"><img src="https://github.com/denizyuret/Knet.jl/blob/master/docs/src/images/RNN-unrolled.png?raw=true" alt="image"/></a></p></blockquote><p>(<a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs">image source</a>)</p><p>As an example, we will build a character-level language model inspired by <a href="http://karpathy.github.io/2015/05/21/rnn-effectiveness">&quot;The Unreasonable Effectiveness of Recurrent Neural Networks&quot;</a> from the Andrej Karpathy blog. The model can be trained with different genres of text, and can be used to generate original text in the same style.</p><p>It turns out simple RNNs are not very good at remembering things for a very long time. Currently the most popular solution is to use a more complicated unit like the Long Short Term Memory (LSTM). An LSTM controls the information flow into and out of the unit using gates similar to digital circuits and can model long term dependencies. See <a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs">Understanding LSTM Networks</a> by Christopher Olah for a good overview of LSTMs.</p><blockquote><p><a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs"><img src="https://github.com/denizyuret/Knet.jl/blob/master/docs/src/images/LSTM3-chain.png?raw=true" alt="image"/></a></p></blockquote><p>(<a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs">image source</a>)</p><p>The code below shows one way to define an LSTM in Knet. The first two arguments are the parameters, the weight matrix and the bias vector. The next two arguments hold the internal state of the LSTM: the hidden and cell arrays. The last argument is the input. Note that for performance reasons we lump all the parameters of the LSTM into one matrix-vector pair instead of using separate parameters for each gate. This way we can perform a single matrix multiplication, and recover the gates using array indexing. We represent input, hidden and cell as row vectors rather than column vectors for more efficient concatenation and indexing. <a href="reference.html#Knet.sigm"><code>sigm</code></a> and <code>tanh</code> are the sigmoid and the hyperbolic tangent activation functions. The LSTM returns the updated state variables <code>hidden</code> and <code>cell</code>.</p><pre><code class="language-julia">function lstm(weight,bias,hidden,cell,input)
    gates   = hcat(input,hidden) * weight .+ bias
    hsize   = size(hidden,2)
    forget  = sigm(gates[:,1:hsize])
    ingate  = sigm(gates[:,1+hsize:2hsize])
    outgate = sigm(gates[:,1+2hsize:3hsize])
    change  = tanh(gates[:,1+3hsize:end])
    cell    = cell .* forget + ingate .* change
    hidden  = outgate .* tanh(cell)
    return (hidden,cell)
end</code></pre><p>The LSTM has an input gate, forget gate and an output gate that control information flow. Each gate depends on the current <code>input</code> value, and the last hidden state <code>hidden</code>. The memory value <code>cell</code> is computed by blending a new value <code>change</code> with the old <code>cell</code> value under the control of input and forget gates. The output gate decides how much of the <code>cell</code> is shared with the outside world.</p><p>If an input gate element is close to 0, the corresponding element in the new <code>input</code> will have little effect on the memory cell. If a forget gate element is close to 1, the contents of the corresponding memory cell can be preserved for a long time. Thus the LSTM has the ability to pay attention to the current input, or reminisce in the past, and it can learn when to do which based on the problem.</p><p>To build a language model, we need to predict the next character in a piece of text given the current character and recent history as encoded in the internal state. The <code>predict</code> function below implements a multi-layer LSTM model. <code>s[2k-1:2k]</code> hold the hidden and cell arrays and <code>w[2k-1:2k]</code> hold the weight and bias parameters for the k&#39;th LSTM layer. The last three elements of <code>w</code> are the embedding matrix and the weight/bias for the final prediction. <code>predict</code> takes the current character encoded in <code>x</code> as a one-hot row vector, multiplies it with the embedding matrix, passes it through a number of LSTM layers, and converts the output of the final layer to the same number of dimensions as the input using a linear transformation. The state variable <code>s</code> is modified in-place.</p><pre><code class="language-julia">function predict(w, s, x)
    x = x * w[end-2]
    for i = 1:2:length(s)
        (s[i],s[i+1]) = lstm(w[i],w[i+1],s[i],s[i+1],x)
        x = s[i]
    end
    return x * w[end-1] .+ w[end]
end</code></pre><p>To train the language model we will use Backpropagation Through Time (BPTT) which basically means running the network on a given sequence and updating the parameters based on the total loss. Here is a function that calculates the total cross-entropy loss for a given (sub)sequence:</p><pre><code class="language-julia">function loss(param,state,sequence,range=1:length(sequence)-1)
    total = 0.0; count = 0
    atype = typeof(getval(param[1]))
    input = convert(atype,sequence[first(range)])
    for t in range
        ypred = predict(param,state,input)
        ynorm = logp(ypred,2) # ypred .- log(sum(exp(ypred),2))
        ygold = convert(atype,sequence[t+1])
        total += sum(ygold .* ynorm)
        count += size(ygold,1)
        input = ygold
    end
    return -total / count
end</code></pre><p>Here <code>param</code> and <code>state</code> hold the parameters and the state of the model, <code>sequence</code> and <code>range</code> give us the input sequence and a possible range over it to process. We convert the entries in the sequence to inputs that have the same type as the parameters one at a time (to conserve GPU memory). We use each token in the given range as an input to predict the next token. The average cross-entropy loss per token is returned.</p><p>To generate text we sample each character randomly using the probabilities predicted by the model based on the previous character:</p><pre><code class="language-julia">function generate(param, state, vocab, nchar)
    index_to_char = Array(Char, length(vocab))
    for (k,v) in vocab; index_to_char[v] = k; end
    input = oftype(param[1], zeros(1,length(vocab)))
    index = 1
    for t in 1:nchar
        ypred = predict(param,state,input)
        input[index] = 0
        index = sample(exp(logp(ypred)))
        print(index_to_char[index])
        input[index] = 1
    end
    println()
end</code></pre><p>Here <code>param</code> and <code>state</code> hold the parameters and state variables as usual. <code>vocab</code> is a Char-\&gt;Int dictionary of the characters that can be produced by the model, and <code>nchar</code> gives the number of characters to generate. We initialize the input as a zero vector and use <code>predict</code> to predict subsequent characters. <code>sample</code> picks a random index based on the normalized probabilities output by the model.</p><p>At this point we can train the network on any given piece of text (or other discrete sequence). For efficiency it is best to minibatch the training data and run BPTT on small subsequences. See <a href="https://github.com/denizyuret/Knet.jl/blob/master/examples/charlm.jl">charlm.jl</a> for details. Here is a sample run on &#39;The Complete Works of William Shakespeare&#39;:</p><pre><code class="language-none">$ cd .julia/Knet/examples
$ wget http://www.gutenberg.org/files/100/100.txt
$ julia charlm.jl --data 100.txt --epochs 10 --winit 0.3 --save shakespeare.jld
... takes about 10 minutes on a GPU machine
$ julia charlm.jl --load shakespeare.jld --generate 1000

    Pand soping them, my lord, if such a foolish?
  MARTER. My lord, and nothing in England&#39;s ground to new comp&#39;d.
    To bless your view of wot their dullst. If Doth no ape;
    Which with the heart. Rome father stuff
    These shall sweet Mary against a sudden him
    Upon up th&#39; night is a wits not that honour,
    Shouts have sure?
  MACBETH. Hark? And, Halcance doth never memory I be thou what
    My enties mights in Tim thou?
  PIESTO. Which it time&#39;s purpose mine hortful and
    is my Lord.
  BOTTOM. My lord, good mine eyest, then: I will not set up.
  LUCILIUS. Who shall</code></pre><h2><a class="nav-anchor" id="Benchmarks-1" href="#Benchmarks-1">Benchmarks</a></h2><p>Each of the examples above was used as a benchmark to compare Knet with other frameworks. The table below shows the number of seconds it takes to train a given model for a particular dataset, number of epochs and minibatch size for Knet, Theano, Torch, Caffe and TensorFlow. Knet has comparable performance to other commonly used frameworks.</p><table><tr><th>model</th><th>dataset</th><th>epochs</th><th>batch</th><th>Knet</th><th>Theano</th><th>Torch</th><th>Caffe</th><th>TFlow</th></tr><tr><td>LinReg</td><td>Housing</td><td>10K</td><td>506</td><td>2.84</td><td>1.88</td><td>2.66</td><td>2.35</td><td>5.92</td></tr><tr><td>Softmax</td><td>MNIST</td><td>10</td><td>100</td><td>2.35</td><td>1.40</td><td>2.88</td><td>2.45</td><td>5.57</td></tr><tr><td>MLP</td><td>MNIST</td><td>10</td><td>100</td><td>3.68</td><td>2.31</td><td>4.03</td><td>3.69</td><td>6.94</td></tr><tr><td>LeNet</td><td>MNIST</td><td>1</td><td>100</td><td>3.59</td><td>3.03</td><td>1.69</td><td>3.54</td><td>8.77</td></tr><tr><td>CharLM</td><td>Hiawatha</td><td>1</td><td>128</td><td>2.25</td><td>2.42</td><td>2.23</td><td>1.43</td><td>2.86</td></tr></table><p>The benchmarking was done on g2.2xlarge GPU instances on Amazon AWS. The code is available at <a href="https://github.com/ozanarkancan/Knet8-Benchmarks">github</a> and as machine image <code>deep_AMI_v6</code> at AWS N.California. See the section on <a href="install.html#Using-Amazon-AWS-1">Using Amazon AWS</a> for more information. The datasets are available online using the following links: <a href="https://archive.ics.uci.edu/ml/datasets/Housing">Housing</a>, <a href="http://yann.lecun.com/exdb/mnist">MNIST</a>, <a href="http://www.gutenberg.org/files/19/19.txt">Hiawatha</a>. The MLP uses a single hidden layer of 64 units. CharLM uses a single layer LSTM language model with embedding and hidden layer sizes set to 256 and trained using BPTT with a sequence length of 100. Each dataset was minibatched and transferred to GPU prior to benchmarking when possible.</p><h2><a class="nav-anchor" id="Under-the-hood-1" href="#Under-the-hood-1">Under the hood</a></h2><p>Knet relies on the <a href="https://github.com/denizyuret/AutoGrad.jl">AutoGrad</a> package and the <a href="reference.html#KnetArray-1">KnetArray</a> data type for its functionality and performance. AutoGrad computes the gradient of Julia functions and KnetArray implements high performance GPU arrays with custom memory management. This section briefly describes them.</p><h3><a class="nav-anchor" id="KnetArrays-1" href="#KnetArrays-1">KnetArrays</a></h3><p>GPUs have become indispensable for training large deep learning models. Even the small examples implemented here run up to 17x faster on the GPU compared to the 8 core CPU architecture we use for benchmarking. However GPU implementations have a few potential pitfalls: (i) GPU memory allocation is slow, (ii) GPU-RAM memory transfer is slow, (iii) reduction operations (like <code>sum</code>) can be very slow unless implemented properly (See <a href="http://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/reduction/doc/reduction.pdf">Optimizing Parallel Reduction in CUDA</a>).</p><p>Knet implements <a href="reference.html#KnetArray-1">KnetArray</a> as a Julia data type that wraps GPU array pointers. KnetArray is based on the more standard <a href="https://github.com/JuliaGPU/CUDArt.jl">CudaArray</a> with a few important differences: (i) KnetArrays have a custom memory manager, similar to <a href="http://arrayfire.com">ArrayFire</a>, which reuse pointers garbage collected by Julia to reduce the number of GPU memory allocations, (ii) array ranges (e.g. <code>a[:,3:5]</code>) are handled as views with shared pointers instead of copies when possible, and (iii) a number of custom CUDA kernels written for KnetArrays implement element-wise, broadcasting, and scalar and vector reduction operations efficiently. As a result Knet allows users to implement their models using high-level code, yet be competitive in performance with other frameworks as demonstrated in the benchmarks section.</p><h3><a class="nav-anchor" id="AutoGrad-1" href="#AutoGrad-1">AutoGrad</a></h3><p>As we have seen, many common machine learning models can be expressed as differentiable programs that input parameters and data and output a scalar loss value. The loss value measures how close the model predictions are to desired values with the given parameters. Training a model can then be seen as an optimization problem: find the parameters that minimize the loss. Typically, a gradient based optimization algorithm is used for computational efficiency: the direction in the parameter space in which the loss reduction is maximum is given by the negative gradient of the loss with respect to the parameters. Thus gradient computations take a central stage in software frameworks for machine learning. In this section I will briefly outline existing gradient computation techniques and motivate the particular approach taken by Knet.</p><p>Computation of gradients in computer models is performed by four main methods <a href="https://arxiv.org/abs/1502.05767">(Baydin et al. 2015)</a>:</p><ul><li><p>manual differentiation (programming the derivatives)</p></li><li><p>numerical differentiation (using finite difference approximations)</p></li><li><p>symbolic differentiation (using expression manipulation)</p></li><li><p>automatic differentiation (detailed below)</p></li></ul><p>Manually taking derivatives and coding the result is labor intensive, error-prone, and all but impossible with complex deep learning models. Numerical differentiation is simple: <span>$f&#39;(x)=(f(x+\epsilon)-f(x-\epsilon))/(2\epsilon)$</span> but impractical: the finite difference equation needs to be evaluated for each individual parameter, of which there are typically many. Pure symbolic differentiation using expression manipulation, as implemented in software such as Maxima, Maple, and Mathematica is impractical for different reasons: (i) it may not be feasible to express a machine learning model as a closed form mathematical expression, and (ii) the symbolic derivative can be exponentially larger than the model itself leading to inefficient run-time calculation. This leaves us with automatic differentiation.</p><p>Automatic differentiation is the idea of using symbolic derivatives only at the level of elementary operations, and computing the gradient of a compound function by applying the chain rule to intermediate numerical results. For example, pure symbolic differentiation of <span>$\sin^2(x)$</span> could give us <span>$2\sin(x)\cos(x)$</span> directly. Automatic differentiation would use the intermediate numerical values <span>$x_1=\sin(x)$</span>, <span>$x_2=x_1^2$</span> and the elementary derivatives <span>$dx_2/dx_1=2x_1$</span>, <span>$dx_1/dx=\cos(x)$</span> to compute the same answer without ever building a full gradient expression.</p><p>To implement automatic differentiation the target function needs to be decomposed into its elementary operations, a process similar to compilation. Most machine learning frameworks (such as Theano, Torch, Caffe, Tensorflow and older versions of Knet prior to v0.8) compile models expressed in a restricted mini-language into a static computational graph of elementary operations that have pre-defined derivatives. There are two drawbacks with this approach: (i) the restricted mini-languages tend to have limited support for high-level language features such as conditionals, loops, helper functions, array indexing, etc. (e.g. the infamous <code>scan</code> operation in Theano) (ii) the sequence of elementary operations that unfold at run-time needs to be known in advance, and they are difficult to handle when the sequence is data dependent.</p><p>There is an alternative: high-level languages, like Julia and Python, already know how to decompose functions into their elementary operations. If we let the users define their models directly in a high-level language, then record the elementary operations during loss calculation at run-time, a dynamic computational graph can be constructed from the recorded operations. The cost of recording is not prohibitive: The table below gives cumulative times for elementary operations of an MLP with quadratic loss. Recording only adds 15% to the raw cost of the forward computation. Backpropagation roughly doubles the total time as expected.</p><table><tr><th>op</th><th>secs</th></tr><tr><td><code>a1=w1*x</code></td><td>0.67</td></tr><tr><td><code>a2=w2.+a1</code></td><td>0.71</td></tr><tr><td><code>a3=max(0,a2)</code></td><td>0.75</td></tr><tr><td><code>a4=w3*a3</code></td><td>0.81</td></tr><tr><td><code>a5=w4.+a4</code></td><td>0.85</td></tr><tr><td><code>a6=a5-y</code></td><td>0.89</td></tr><tr><td><code>a7=sumabs2(a6)</code></td><td>1.18</td></tr><tr><td>+recording</td><td>1.33</td></tr><tr><td>+backprop</td><td>2.79</td></tr></table><p>This is the approach taken by the popular <a href="https://github.com/HIPS/autograd">autograd</a> Python package and its Julia port <a href="https://github.com/denizyuret/AutoGrad.jl">AutoGrad.jl</a> used by Knet. Recently, other machine learning frameworks have been adapting dynamic computational graphs: <a href="http://docs.chainer.org/en/stable/index.html">Chainer</a>, <a href="https://arxiv.org/abs/1701.03980">DyNet</a>, <a href="https://github.com/pytorch/pytorch">PyTorch</a>, <a href="https://research.googleblog.com/2017/02/announcing-tensorflow-fold-deep.html">TensorFlow Fold</a>.</p><p>In Knet <code>g=grad(f)</code> generates a gradient function <code>g</code>, which takes the same inputs as the function <code>f</code> but returns the gradient. The gradient function <code>g</code> triggers recording by boxing the parameters in a special data type and calls <code>f</code>. The elementary operations in <code>f</code> are overloaded to record their actions and output boxed answers when their inputs are boxed. The sequence of recorded operations is then used to compute gradients. In the Julia AutoGrad package, derivatives can be defined independently for each method of a function (determined by argument types) making full use of Julia&#39;s multiple dispatch. New elementary operations and derivatives can be defined concisely using Julia&#39;s macro and meta-programming facilities. See <a href="https://github.com/denizyuret/AutoGrad.jl">AutoGrad.jl</a> for details.</p><h2><a class="nav-anchor" id="Contributing-1" href="#Contributing-1">Contributing</a></h2><p>Knet is an open-source project and we are always open to new contributions: bug reports and fixes, feature requests and contributions, new machine learning models and operators, inspiring examples, benchmarking results are all welcome. If you would like to contribute to Knet development, check out the <a href="https://groups.google.com/forum/#!forum/knet-dev">knet-dev</a> mailing list and <a href="install.html#Tips-for-developers-1">Tips for developers</a>.</p><p>Current contributors:</p><ul><li><p>Deniz Yuret</p></li><li><p>Ozan Arkan Can</p></li><li><p>Onur Kuru</p></li><li><p>Emre Ünal</p></li><li><p>Erenay Dayanık</p></li><li><p>Ömer Kırnap</p></li><li><p>İlker Kesen</p></li><li><p>Emre Yolcu</p></li><li><p>Meriç Melike Softa</p></li><li><p>Ekrem Emre Yurdakul</p></li><li><p>Enis Berk</p></li></ul><footer><hr/><a class="previous" href="install.html"><span class="direction">Previous</span><span class="title">Setting up Knet</span></a><a class="next" href="examples.html"><span class="direction">Next</span><span class="title">Examples</span></a></footer></article></body></html>
