<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Softmax Classification · Knet.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script></head><body><nav class="toc"><h1>Knet.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="install.html">Setting up Knet</a></li><li><a class="toctext" href="tutorial.html">Introduction to Knet</a></li><li><a class="toctext" href="examples.html">Examples</a></li><li><a class="toctext" href="reference.html">Reference</a></li></ul></li><li><span class="toctext">Textbook</span><ul><li><a class="toctext" href="backprop.html">Backpropagation</a></li><li class="current"><a class="toctext" href="softmax.html">Softmax Classification</a><ul class="internal"><li><a class="toctext" href="#Classification-1">Classification</a></li><li><a class="toctext" href="#Likelihood-1">Likelihood</a></li><li><a class="toctext" href="#Softmax-1">Softmax</a></li><li><a class="toctext" href="#One-hot-vectors-1">One-hot vectors</a></li><li><a class="toctext" href="#Gradient-of-log-likelihood-1">Gradient of log likelihood</a></li><li><a class="toctext" href="#MNIST-example-1">MNIST example</a></li><li><a class="toctext" href="#Representational-power-1">Representational power</a></li><li><a class="toctext" href="#References-1">References</a></li></ul></li><li><a class="toctext" href="mlp.html">Multilayer Perceptrons</a></li><li><a class="toctext" href="cnn.html">Convolutional Neural Networks</a></li><li><a class="toctext" href="rnn.html">Recurrent Neural Networks</a></li><li><a class="toctext" href="rl.html">Reinforcement Learning</a></li><li><a class="toctext" href="opt.html">Optimization</a></li><li><a class="toctext" href="gen.html">Generalization</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Textbook</li><li><a href="softmax.html">Softmax Classification</a></li></ul><a class="edit-page" href="https://github.com/denizyuret/Knet.jl/tree/091f3dd4e7fb14ada4e66ea6d09e344e1a399ea1/docs/src/softmax.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Softmax-Classification-1" href="#Softmax-Classification-1">Softmax Classification</a></h1><div class="admonition note"><div class="admonition-title">Concepts</div><div class="admonition-text"><p>classification, likelihood, softmax, one-hot vectors, zero-one loss, conditional likelihood, MLE, NLL, cross-entropy loss</p></div></div><p>We will introduce classification problems and some simple models for classification.</p><h2><a class="nav-anchor" id="Classification-1" href="#Classification-1">Classification</a></h2><p>Classification problems are supervised machine learning problems where the task is to predict a discrete class for a given input (unlike regression where the output was numeric). A typical example is handwritten digit recognition where the input is an image of a handwritten digit, and the output is one of the discrete categories <span>$\{0, \ldots, 9\}$</span>. As in all supervised learning problems the training data consists of a set of example input-output pairs.</p><h2><a class="nav-anchor" id="Likelihood-1" href="#Likelihood-1">Likelihood</a></h2><p>A natural objective in classification could be to minimize the number of misclassified examples in the training data. This number is known as the <strong>zero-one loss</strong>. However the zero-one loss has some undesirable properties for training: in particular it is discontinuous. A small change in one of the parameters either has no effect on the loss, or can turn one or more of the predictions from false to true or true to false, causing a discontinuous jump in the objective. This means the gradient of the zero-one loss with respect to the parameters is either undefined or not helpful.</p><p>A more commonly used objective for classification is conditional likelihood: the probability of the observed data given our model <em>and the inputs</em>. Instead of predicting a single class for each instance, we let our model predict a probability distribution over all classes. Then we adjust the weights of the model to increase the probabilities for the correct classes and decrease it for others. This is also known as the <strong>maximum likelihood estimation</strong> (MLE).</p><p>Let <span>$\mathcal{X}=\{x_1,\ldots,x_N\}$</span> be the inputs in the training data, <span>$\mathcal{Y}=\{y_1,\ldots,y_N\}$</span> be the correct classes and <span>$\theta$</span> be the parameters of our model. Conditional likelihood is:</p><div>\[L(\theta) = P(\mathcal{Y}|\mathcal{X},\theta) 
= \prod_{n=1}^N P(y_n|x_n,\theta)\]</div><p>The second equation assumes that the data instances were generated independently. We usually work with log likelihood for mathematical convenience: log is a monotonically increasing function, so maximizing likelihood is the same as maximizing log likelihood:</p><div>\[\ell(\theta) = \log P(\mathcal{Y}|\mathcal{X},\theta) 
= \sum_{n=1}^N \log P(y_n|x_n,\theta)\]</div><p>We will typically use the negative of <span>$\ell$</span> (machine learning people like to minimize), which is known as <strong>negative log likelihood</strong> (NLL), or <strong>cross-entropy loss</strong>.</p><h2><a class="nav-anchor" id="Softmax-1" href="#Softmax-1">Softmax</a></h2><p>The linear regression model we have seen earlier produces unbounded <span>$y$</span> values. To go from arbitrary values <span>$y\in\mathbb{R}^C$</span> to normalized probability estimates <span>$p\in\mathbb{R}^C$</span> for a single instance, we use exponentiation and normalization:</p><div>\[p_i = \frac{\exp y_i}{\sum_{c=1}^C \exp y_c}\]</div><p>where <span>$i,c\in\{1,\ldots,C\}$</span> range over classes, and <span>$p_i, y_i, y_c$</span> refer to class probabilities and values for a single instance. This is called the <strong>softmax function</strong>. A model that converts the unnormalized values at the end of a linear regression to normalized probabilities for classification is called the <strong>softmax classifier</strong>.</p><p>We need to figure out the backward pass for the softmax function. In other words if someone gives us the gradient of some objective <span>$J$</span> with respect to the class probabilities <span>$p$</span> for a single training instance, what is the gradient with respect to the input of the softmax <span>$y$</span>? First we&#39;ll find the partial derivative of one component of <span>$p$</span> with respect to one component of <span>$y$</span>:</p><div>\[\frac{\partial p_i}{\partial y_j} 
= \frac{[i=j] \exp y_i \sum_c \exp y_c - \exp y_i \exp y_j}{(\sum_c \exp y_c)^2}
= \,[i=j]\, p_i - p_i p_j\]</div><p>The square brackets are the <a href="https://en.wikipedia.org/wiki/Iverson_bracket">Iverson bracket</a> notation, i.e. <span>$[A]$</span> is 1 if <span>$A$</span> is true, and 0 if <span>$A$</span> is false.</p><p>Note that a single entry in <span>$y$</span> effects <span>$J$</span> through multiple paths (<span>$y_j$</span> contributes to the denominator of every <span>$p_i$</span>), and these effects need to be added for <span>$\partial J/\partial y_j$</span>:</p><div>\[\frac{\partial J}{\partial y_j}
= \sum_{i=1}^C \frac{\partial J}{\partial p_i}
\frac{\partial p_i}{\partial y_j}\]</div><h2><a class="nav-anchor" id="One-hot-vectors-1" href="#One-hot-vectors-1">One-hot vectors</a></h2><p>When using a probabilistic classifier, it is convenient to represent the desired output as a <strong>one-hot vector</strong>, i.e. a vector in which all entries are &#39;0&#39; except a single &#39;1&#39;. If the correct class is <span>$c\in\{1,\ldots,C\}$</span>, we represent this with a one-hot vector <span>$p\in\mathbb{R}^C$</span> where <span>$p_c = 1$</span> and <span>$p_{i\neq c} = 0$</span>. Note that <span>$p$</span> can be viewed as a probability vector where all the probability mass is concentrated at c. This representation also allows us to have probabilistic targets where there is not a single answer but target probabilities associated with each answer. Given a one-hot (or probabilistic) <span>$p$</span>, and the model prediction <span>$\hat{p}$</span>, we can write the log-likelihood for a single instance as:</p><div>\[\ell = \sum_{c=1}^C p_c \log \hat{p}_c\]</div><h2><a class="nav-anchor" id="Gradient-of-log-likelihood-1" href="#Gradient-of-log-likelihood-1">Gradient of log likelihood</a></h2><p>To compute the gradient for log likelihood, we need to make the normalization of <span>$\hat{p}$</span> explicit:</p><div>\[\begin{align*}
\ell &amp;= \sum_c p_c \log \frac{\hat{p}_c}{\sum_k\hat{p}_k} \\
&amp;= \sum_c p_c \log{\hat{p}_c} - \sum_c p_c \log \sum_k\hat{p}_k \\
&amp;= (\sum_c p_c \log{\hat{p}_c}) - (\log \sum_k\hat{p}_k) \\
\frac{\partial \ell}{\partial \hat{p}_i} &amp;=
\frac{p_i}{\hat{p}_i} - \frac{1}{\sum_k\hat{p}_k}
= \frac{p_i}{\hat{p}_i} - 1
\end{align*}\]</div><p>The gradient with respect to unnormalized y takes a particularly simple form:</p><div>\[\begin{align*}
\frac{\partial\ell}{\partial y_j}
&amp;= \sum_i \frac{\partial\ell}{\partial \hat{p}_i}
\frac{\partial \hat{p}_i}{\partial y_j} \\
&amp;= \sum_i (\frac{p_i}{\hat{p}_i} - 1)(\,[i=j]\, \hat{p}_i - \hat{p}_i \hat{p}_j) \\
&amp;= \, p_j - \hat{p}_j \\
\nabla\ell &amp;= \, p - \hat{p}
\end{align*}\]</div><p>The gradient with respect to <span>$\hat{p}$</span> causes numerical overflow when some components of <span>$\hat{p}$</span> get very small. In practice we usually skip that and directly compute the gradient with respect to <span>$y$</span> which is numerically stable.</p><h2><a class="nav-anchor" id="MNIST-example-1" href="#MNIST-example-1">MNIST example</a></h2><p>Let&#39;s try our softmax classifier on the <a href="http://yann.lecun.com/exdb/mnist">MNIST</a> handwritten digit classification dataset. Here are the first 8 images from MNIST, the goal is to look at the pixels and classify each image as one of the digits 0-9:</p><p><img src="images/firsteightimages.jpg" alt="image"/></p><p>See training-with-minibatches for more information about the MNIST task, loading and minibatching data, and simple train and test scripts.</p><p>Here is the softmax classifier in Julia:</p><pre><code class="language- sourceCode">function softmax(w,x,ygold)
    ypred = w[1] * x .+ w[2]
    return softloss(ygold, ypred)
end

function softloss(ygold, ypred)
    ynorm = ypred .- log(sum(exp(ypred),1))
    -sum(ygold .* ynorm) / size(ygold,2)
end

softmax_gradient = grad(softmax)</code></pre><pre><code class="language- sourceCode">...</code></pre><p>Let us train our model for 100 epochs and print out the classification error on the training and test sets after every epoch (see the full example in Pkg.dir(&quot;Knet/examples/mnist.jl&quot;)):</p><pre><code class="language- sourceCode">w = Any[0.1*randn(10,784), zeros(10,1)]
for epoch=1:nepochs
    for (x,y) in dtrn  # dtrn is a list of minibatches
        g = softmax_gradient(w, x, y)
        for i in 1:length(w)
            w[i] -= lr * g[i]
        end
    end
# Print accuracy
end</code></pre><p>Here is a plot of the losses vs training epochs:</p><p><img src="images/mnist_softmax.png" alt="image"/></p><p>We can observe a few things. First the training losses are better than the test losses. This means there is some <strong>overfitting</strong>. Second, it does not look like the training loss is going down to zero. This means the softmax model is not flexible enough to fit the training data exactly.</p><h2><a class="nav-anchor" id="Representational-power-1" href="#Representational-power-1">Representational power</a></h2><p>So far we have seen how to create a machine learning model as a differentiable program (linear regression, softmax classification) whose parameters can be adjusted to hopefully imitate whatever process generated our training data. A natural question to ask is whether a particular model can behave like any system we want (given the right parameters) or whether there is a limit to what it can represent.</p><p>It turns out the softmax classifier is quite limited in its representational power: it can only represent linear classification boundaries. To show this, remember the form of the softmax classifier which gives the probability of the i&#39;th class as:</p><div>\[p_i = \frac{\exp y_i}{\sum_{c=1}^C \exp y_c}\]</div><p>where <span>$y_i$</span> is a linear function of the input <span>$x$</span>. Note that <span>$p_i$</span> is a monotonically increasing function of <span>$y_i$</span>, so for two classes <span>$i$</span> and <span>$j$</span>, <span>$p_i &gt; p_j$</span> if <span>$y_i &gt; y_j$</span>. The boundary between two classes <span>$i$</span> and <span>$j$</span> is the set of inputs for which the probability of the two classes are equal:</p><div>\[\begin{align*}
p_i &amp;= p_j \\
y_i &amp;= y_j \\
w_i x + b_i &amp;= w_j x + b_j \\
(w_i - w_j) x + (b_i - b_j) &amp;= 0
\end{align*}\]</div><p>where <span>$w_i, b_i$</span> refer to the i&#39;th row of <span>$w$</span> and <span>$b$</span>. This is a linear equation, i.e. the border between two classes will always be linear in the input space with the softmax classifier:</p><p><img src="images/linear-boundary.png" alt="image"/></p><p>In the MNIST example, the relation between the pixels and the digit classes is unlikely to be this simple. That is why we are stuck at 6-7% training error. To get better results we need more powerful models.</p><h2><a class="nav-anchor" id="References-1" href="#References-1">References</a></h2><ul><li><p><a href="http://ufldl.stanford.edu/tutorial/supervised/SoftmaxRegression">UFLDL Tutorial, Softmax Regression</a></p></li></ul><footer><hr/><a class="previous" href="backprop.html"><span class="direction">Previous</span><span class="title">Backpropagation</span></a><a class="next" href="mlp.html"><span class="direction">Next</span><span class="title">Multilayer Perceptrons</span></a></footer></article></body></html>
